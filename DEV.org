#+title: Hyperdrive.el notes

* PROJECT Petnames
:PROPERTIES:
:ID:       e5b0c0f1-7ebc-4e8c-9712-cd2cd4a055ce
:END:
:LOGBOOK:
- State "PROJECT"    from              [2023-03-23 Thu 17:59]
:END:

** Design
:PROPERTIES:
:ID:       a7d0005c-a219-4cae-a32f-6bf7b2e7a8fb
:END:

+ [ ] Add appropriate sections of these design notes to the project docs.

+ *Terminology*
  + Nickname :: What we have been calling "public names" (the string loaded from the ~/.well-known/host-meta~ file) is now going to be called the "nickname."
  + Petname :: given by each local user to one and only one hyperdrive.
  + Public key :: the public key address of the hyperdrive.
  + Seed :: the value from which the public key is generated by hyper-gateway.
  + Domains :: One or more DNS names that are configured with DNSLink records to point to a hyperdrive.

+ *Internals*
  + [X] Add a ~petname~ field to the ~hyperdrive~ struct.
  + [X] Add /petnames/ support to ~hyperdrive--format-host~.
  + [X] Add petname to ~hyperdrive-default-host-format~.
  + [X] Add petname face.
  + [X] Add faces for all types of hostname formats.
  + [X] Change ~public-name~ to ~nickname~ everywhere.
  + [X] Consider adding ~:with-label t~ to everywhere ~hyperdrive--format-host~ is called.
  + [X] Add a command to set a petname.

+ *UI*
  + The user must be able to clearly distinguish between petnames, nicknames, and public keys.  Each type should be visually distinctive and umambiguous.

  + [X] Empty string as a petname should be treated as an unset petname.
  + [ ] Have an option to automatically prompt the user to set a petname for newly visited hyperdrives.
  + [ ] Have an option to automatically prompt the user to set a nickname for newly visited hyperdrives.

  + *Considerations*
    + Privacy :: If /petnames/ leak (e.g. when sharing links, or in a file in ~/.emacs.d that gets committed to git and published to a public repo), it could reveal personal information (like what someone thinks of another person).
      + Is this a problem?  Is it okay for them to "leak"?  Should they even be considered private?

  + Where the /petname/ should be displayed:
    + [X] Directory header
    + [X] Buffer name
    + [X] describe-hyperdrive buffer
    + [X] Hyperdrive completion
    + [ ] When naming a link
    + [ ] When naming a bookmark

  + *Flows*

    + Creating a new hyperdrive ::
      1. Prompt the user for the /seed/.
      2. Prompt the user for the /petname/, using the /seed/ as the default value.
      3. Show the new hyperdrive's directory buffer.

    + Assigning petnames to existing hyperdrives ::
      1. Call a command to set the petname of a hyperdrive (defaulting to the one relating to the current buffer).
      2. Enter the new petname.
      3. Verify that it the petname isn't already assigned to another hyperdrive.
      4. Set the new petname in the struct.
      5. Persist the struct?

    + Removing petnames from hyperdrives ::
      1. Document that setting a petname to the empty string is considered unsetting the petname.

* PROJECT Versioning
:PROPERTIES:
:ID:       52bbabe0-dba6-4912-8f4d-0fa8b34babfa
:END:
:LOGBOOK:
- State "PROJECT"    from              [2023-04-04 Tue 14:27]
:END:

+ https://todo.sr.ht/~ushin/ushin/1

** Design

+ *Concepts*
  + Special folder :: Folder at root level of hyperdrive that is not returned in directory listing.  Named ~$~.  Requests for old versions are sent to ~$/version/~.  See: [[https://github.com/RangerMauve/hypercore-fetch#fetchhypernameversionversion_numberexampletxt][hypercore-fetch docs]].
  + ETag :: Version numbers are sent in responses in the ~ETag~ header.
    + NOTE: hyper-gateway's behavior in this regard may change soon.  See: [[https://github.com/RangerMauve/hypercore-fetch/issues/65][#65]].
    + Requests for directories always return the current version of the hyperdrive, unless the version is specified in the request.
  + URL :: URLs pointing at specific versions of a file will have the version number in the URL.
    + This is necessary so that URLs can link to specific versions of a file (i.e. there is no other way to specify the version in a request that would make this possible).

+ *Internals*
  + ~hyperdrive-entry~ already has an ~etag~ slot.
  + If a ~hyperdrive-entry-equalp~ function is needed in the future, it should compare the ~etag~ slot.
  + When viewing old versions of a directory or file, the buffer name should include the version number.
  + When an old version is not found, hyperdrive.el should not try to load

+ *UI*

  + *Flows*

    + Time machine :: Allowing the user to "go back in time" (and forward) and view various versions of entries.

      + ~hyperdrive-previous-version~ :: Show the previous version of the file.
        + [ ] If the current version of the file is the earliest, show a useful error.

      + ~hyperdrive-next-version~ :: Show the next version of the file.
        + *NOTE*: The hyper-gateway API doesn't seem to currently offer a way to retrieve the /next/ version of an entry, given an entry at a version.  Iterating backward from the latest version would be impractical.

        + [ ] If that version is also the current version, it should act as if the user requested the file without specifying a version.  See [[https://github.com/RangerMauve/hypercore-fetch/issues/72]].


** Examples

/This example is written at a point in time at which hyper-gateway returns the *previous* version of the file as the =ETag=.  When https://github.com/RangerMauve/hypercore-fetch/issues/65 is done, this example will match reality./

1. File A created at version 10.
2. File A modified at version 15.
3. File A modified at version 20.
4. Current version of hyperdrive is 25.
5. Request for hyper://PUBLIC-KEY/file-a returns an =ETag= of 20.
6. Request for hyper://PUBLIC-KEY/$/version/20/file-a returns an =ETag= of 20.
7. Request for hyper://PUBLIC-KEY/$/version/19/file-a returns an =ETag= of 15.
8. Request for hyper://PUBLIC-KEY/$/version/14/file-a returns an =ETag= of 10.
9. Request for hyper://PUBLIC-KEY/$/version/9/file-a returns HTTP 404 with =ETag= 0.


* Response matrix
:PROPERTIES:
:ID:       3381f0a8-7d75-4e1e-90e4-f4d9adf6015e
:END:

Currently observed behavior.

| Request for                                           | Returns         | # |
|-------------------------------------------------------+-----------------+---|
| URL to valid hyperdrive without content               | Etag == 1       |   |
| URL to unknown (i.e. network-inaccessible) hyperdrive | Etag == 1       | ! |
| URL to valid hyperdrive that has ever had content     | Etag > 1        |   |
| URL to valid hyperdrive directory but invalid file    | HTTP 404        |   |
| URL with too-short public key                         | HTTP 500        |   |

** Ideals?
:PROPERTIES:
:ID:       3f2fa76c-0a35-4b5f-bc8e-91a2d55c6db2
:END:

What we'd ideally like the behavior to be.

| Request for                           | HTTP            | Etag |
|---------------------------------------+-----------------+------|
| Obviously malformed URLs              | 400 Bad Request | N/A  |
| [[id:5951fa2d-6f95-41e0-9fd0-066ae06dbc3e][Unknown hyperdrive]]                    | 404 Not Found   | N/A  |
| [[id:aeb2dcd3-ec0f-42a6-aec2-9a7ba6eb163f][Known hyperdrive (never had content)]]  | 204 No Content  | N/A  |
| Known hyperdrive (has or had content) | 200 OK          | >= 1 |

To distinguish whether peers are available, ideally we would use another header, something like ~X-Hyperdrive-Peers~.

** Glossary

*** Unknown hyperdrive
:PROPERTIES:
:ID:       5951fa2d-6f95-41e0-9fd0-066ae06dbc3e
:END:

An unknown hyperdrive may or may not exist.  We don't know whether it does.  We have never received any information about it.

*** Known hyperdrive (never had content)
:PROPERTIES:
:ID:       aeb2dcd3-ec0f-42a6-aec2-9a7ba6eb163f
:END:

A hyperdrive that we know exists, and we know it is empty, and it has never yet had any content.  Possibly created by us.

* File interaction matrix

What Emacs does:

| Buffer backed by | Command      | buffer-file-name                        | buffer-name             |
|------------------+--------------+-----------------------------------------+-------------------------|
| nothing          | write-buffer | prompts for and changes to new filename | changes to new basename |
| nothing          | save-buffer  | prompts for and changes to new filename | changes to new basename |
| file on disk     | write-buffer | prompts for and changes to new filename | changes to new basename |
| file on disk     | save-buffer  | does not change                         | does not change         |

What hyperdrive does:

| Buffer backed by             | Command                 | Correct behavior? |
|------------------------------+-------------------------+-------------------|
| nothing                      | hyperdrive-write-buffer | yes               |
| nothing                      | hyperdrive-save-buffer  | yes               |
| file on disk                 | hyperdrive-write-buffer | yes               |
| file on disk                 | hyperdrive-save-buffer  | yes               |
| file on writable hyperdrive  | hyperdrive-write-buffer | yes               |
| file on writable hyperdrive  | hyperdrive-save-buffer  | yes               |
| file on read-only hyperdrive | hyperdrive-save-buffer  | yes               |
| file on read-only hyperdrive | hyperdrive-write-buffer | yes               |

** Overwriting existing Hyperdrive files

| Hyperdrive URL status | Command      | Should                      | Correct behavior? |
|-----------------------+--------------+-----------------------------+-------------------|
| Already exists        | write-buffer | Prompt to overwrite         |                   |
| Already exists        | save-buffer  | Overwrite without prompting |                   |

* DONE Conference presentation
:LOGBOOK:
- State "DONE"       from "PROJECT"    [2023-04-04 Tue 13:33] \\
  GREAT SUCCESS!
:END:

** DONE Screencast
DEADLINE: <2023-03-09 Thu>
:LOGBOOK:
- State "DONE"       from "PROJECT"    [2023-04-04 Tue 13:33]
- State "PROJECT"    from              [2023-02-28 Tue 18:13]
:END:

*** Issues to solve before screencast

+ [X] [[https://todo.sr.ht/~ushin/ushin/21][~ushin/ushin#21: Store link with search options in `hyperdrive-store-link` — sourcehut todo]]
+ [X] [[https://todo.sr.ht/~ushin/ushin/17][~ushin/ushin#17: Handle uri-encoding — sourcehut todo]] (maybe not absolutely necessary for screencast)

* Peer discovery (swarming)

** How to connect to a peer

~PUBLIC-KEY~ must be writable on both machines.

1. Alice ~GET hyper://PUBLIC-KEY/$/extensions/foo~
2. Alice ~POST hyper://PUBLIC-KEY/$/extensions/foo~ with body string
3. Send ~GET hyper://PUBLIC-KEY/$/extensions/~ to verify that the ~foo~
   extension is being advertised.
4. After Alice has ~GET hyper://PUBLIC-KEY/$/extensions/foo~

** How hyperdrive.el will use extension messages

Advertise on one or more topics. On connection with another peer, send
an extension message with a newline-delimited list of hyperdrive
public keys which are known to be relevant to that topic.

** Questions

*** TODO What difference should it make to send requests to different public keys (writable or non-writable)?

Currently, ~GET hyper://BAZ/$/extensions/foo~ and ~GET
hyper://BAR/$/extensions/foo~ give different results. (or does only
make a difference between writable and non-writable public keys?)

*** TODO Reverse DNS namespacing

Regarding the way we use extension messages, would it make sense to
use reverse DNS namespacing for extension message topics, e.g.,
.org.ushin.hyperdrive.topics.foo

*** TODO request.text

In hypercore-fetch's broadcastExtension() method, await request.text
is used, but in extensionToPeer(), await request.arrayBuffer is used.
Should we always use request.text?

*** TODO Return response headers immediately
~GET hyper://PUBLIC-KEY/$/extensions/~ with Accept: text/event-stream
header only returns response headers after first event is received.
Should it return response headers first?

*** TODO non-advertised topics appear in list

If already connected to another peer, ~GET
hyper://PUBLIC-KEY/$/extensions/not-advertising-this~ lists that peer
even when that peer is not advertising the topic ~not-advertising-this~.

*** TODO How to tell the gateway that you're no longer interested in a topic?

*** TODO We saw a "peer-remove" event when the gateway shut down, but no "peer-open".

*** TODO What topic do we have in common?

How to tell which extension caused a peer-open or peer-remove event?

*  Org link tests

This subtree helps us understand and test the different kinds of Org links and whether and how they should work in various contexts.

NOTE: This file should be loaded from a hyperdrive in order to verify that these links work correctly for an Org file loaded from a hyperdrive.

To decode these links with Org, use ~(org-element-context)~ with point on the link.  The resulting element/plist is used in function ~hyperdrive--org-open-at-point~.

** Link types

Here are various link types which we want to test.

*** ~hyper://~-prefixed, with or without brackets

**** Links without targets

+ [[hyper://PUBLIC_KEY/links.org]]
+ hyper://PUBLIC_KEY/links.org

**** Links with targets

*NOTE:* While in Org mode, these anchored links can only point to headings with matching ~CUSTOM_ID~ properties, in hyperdrive we first check for matching ~CUSTOM_ID~, then ~ID~, then exact heading title content matches.  (The anchor part is URL-decoded and the leading ~#~ is discarded.)

+ [[hyper://PUBLIC_KEY/links.org#Heading%20A]]
+ hyper://PUBLIC_KEY/links.org#Heading%20A

*** Non-~hyper://~-prefixed links (inside brackets)


**** Links without targets

/Link to a file, without specifying a heading within it./

***** Links to hyperdrive files

/Note the lack of ~file:~ prefix, which would indicate a link to a local file./

+ [[./links.org]]
+ [[/links.org]] :: For non-hyperdrive files, this actually links to a file in the root directory of the filesystem.  For hyperdrives, we want this to point to a file in the hyperdrive's root.

****** TODO Fix functionality for links like ~[[links.org]]~
:LOGBOOK:
- State "TODO"       from              [2023-08-29 Tue 16:40]
:END:

Org doesn't support this for local files (this syntax would point to a heading by that name), so we should follow Org here.  This is actually a bug.

***** Links to local files

/The ~file:~ prefix indicates that the link points to a local file (not one on a hyperdrive relative to the current hyperdrive file)/.

+ [[file:./links.org]]
+ [[file:links.org]]

**** Links with targets

/Links to headings within a file, rather than links to the file./

***** ~*~-prefixed heading names
:LOGBOOK:
- Note taken on [2023-08-29 Tue 15:53] \\
  This does not currently work in hyperdrive-mode.
- State "TODO"       from              [2023-08-29 Tue 15:53]
:END:

****** TODO Unspecified file (same file)
:LOGBOOK:
- State "TODO"       from              [2023-08-29 Tue 15:58]
:END:

/Links to headings within the file containing the link.  The filename is not specified./

+ [[*Heading A]]

****** TODO Specified file
:LOGBOOK:
- State "TODO"       from              [2023-08-29 Tue 15:58]
:END:

/Links to headings in a specified file, potentially a different one./

+ [[./links.org::*Heading A]]
+ [[/links.org::*Heading A]]

***** Unprefixed heading names

/Without a ~*~ or ~./~, the link is intended to point to a heading within the same document./

****** Unspecified file (same file)

+ [[Heading A]]

****** Specified file

+ [[./links.org::Heading A]]
+ [[/links.org::Heading A]]

***** Custom IDs: HTML-style, ~#~-anchor-suffixed links

****** TODO Unspecified file (same file)
:LOGBOOK:
- State "TODO"       from              [2023-08-29 Tue 15:58]
:END:

+ [[#Heading%20A]]

  + This is currently looking for a heading with the ~#~ as part of its actual entry; it should be removing the ~#~ before calling ~org-find-exact-headline-in-buffer~.

      #+begin_src elisp
      (hyperdrive--org-link-goto "#Heading%20A")
      #+end_src

****** TODO Specified file
:LOGBOOK:
- State "TODO"       from              [2023-08-29 Tue 15:58]
:END:

+ [[./links.org#Heading%20A]]
+ [[/links.org#Heading%20A]]

***** Regexp searches for file content

We do not currently support this.

** Test data

Below this line is a series of headings we use to link to for testing purposes.

*** Heading A

/Heading without IDs (link to heading text)./

*** Heading A

/This intentionally duplicates the previous heading for testing purposes./

*** Heading with CUSTOM_ID
:PROPERTIES:
:CUSTOM_ID: hyperdrive-foo
:END:

*** Heading with ID
:PROPERTIES:
:ID:       hyperdrive-bar
:END:
